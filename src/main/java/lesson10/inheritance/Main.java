package lesson10.inheritance;

/*
OVERRIDING - переопределение методов, часть полиморфизма
это возможность реализации метода в подклассе, который уже существует в суперклассе или родительском классе.
Любой подкласс обычно может переопределить любой метод из суперкласса, если только метод не помечен ключевыми словами final или static.
Метод переопределения не должен изменять имя и список параметров переопределяемого метода.
Хотя это и не обязательно, но рекомендуется использовать аннотацию @Override при переопределении метода:
эта аннотация проверит правильность переопределения метода и предупредит вас, если это не так.

Ключевые правила переопределения методов
- Список параметров не должен меняться: переопределяющий метод должен принимать то же количество и тип параметров, что и переопределяемый метод, иначе вы просто перегрузите метод.
- Тип возвращаемого значения не должен изменяться (Примечание: если метод возвращает объект, то в качестве типа возвращаемого значения допускается подкласс этого объекта).
- Модификатор доступа должен быть таким же или менее ограничивающим (например, если переопределяемый метод — protected, вы можете объявить переопределяющий метод как public, но не private).
- Выброшенные проверенные исключения, если таковые имеются, могут быть удалены или сокращены методом переопределения.
Это означает, что переопределяющий метод может генерировать то же проверенное исключение, что и переопределенный метод, или подкласс этого проверенного исключения, но не более широкое исключение.
Это ограничение не распространяется на непроверенные исключения.

Основная цель переопределения метода — реализация того же метода с тем же списком параметров в подклассе,
чтобы адаптировать его поведение к потребностям подкласса.

В отличие от перегрузки метода, где цель — изменить список параметров метода,
чтобы реализовать другое поведение на основе переданных ему аргументов.
*/


public class Main {
    public static void main(String[] args) {
        Parent parent = new Parent();
        parent.setNumber(12);
        System.out.println(parent.getNumber());

        Child child = new Child();
        child.setNumber(1222);
        child.name = "child";
        System.out.println(child.getName());
        System.out.println(child.getNumber());
        //хотя у child этот метод явно не прописан, он есть у его родителя
        System.out.println(child.toString());
        //хотя у child и у parent этот метод явно не прописан, он есть у Object

        Grandchild grandchild = new Grandchild("Ivanov");
        grandchild.name = "Petr";
        grandchild.setNumber(17);
        System.out.println(grandchild.getName());
        System.out.println(grandchild.lastName);

        Parent p = new Grandchild("xxx");
        //Grandchild может исполнять обязанности Parent, но тогда мы потеряем доступ к его уникальным свойствам

        Parent[] ps = {parent, child, grandchild};
        // все эти объекты выполняют контракт Parent, т.к они все наследники
        // имеют его поля и методы

        for (Parent pt : ps) {
            System.out.println(pt.getNumber());
            System.out.println(pt.toString());
        }

        System.out.println(parent.whoAmI());
        System.out.println(child.whoAmI());
        System.out.println(grandchild.whoAmI());

        GrandGrandChild grandGrandChild = new GrandGrandChild("Sidorov", "Roman");
        System.out.println(grandGrandChild.lastName);

    }
}
